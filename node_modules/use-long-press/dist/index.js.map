{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n    MouseEvent,\n    MouseEventHandler,\n    TouchEvent,\n    TouchEventHandler,\n    useCallback,\n    useEffect,\n    useRef,\n} from 'react';\n\nconst noop = (): void => {};\n\nexport type LongPressEvent<Target = Element> = MouseEvent<Target> | TouchEvent<Target>;\nexport type LongPressCallback<Target = Element> = (event?: LongPressEvent<Target>) => void;\nexport enum LongPressDetectEvents {\n    BOTH = 'both',\n    MOUSE = 'mouse',\n    TOUCH = 'touch',\n}\n\nexport type LongPressResult<\n    Target,\n    Callback,\n    DetectType extends LongPressDetectEvents = LongPressDetectEvents.BOTH\n> = DetectType extends LongPressDetectEvents.BOTH\n    ? {\n          onMouseDown: MouseEventHandler<Target>;\n          onMouseUp: MouseEventHandler<Target>;\n          onMouseLeave: MouseEventHandler<Target>;\n          onTouchStart: TouchEventHandler<Target>;\n          onTouchEnd: TouchEventHandler<Target>;\n      }\n    : DetectType extends LongPressDetectEvents.MOUSE\n    ? {\n          onMouseDown: MouseEventHandler<Target>;\n          onMouseUp: MouseEventHandler<Target>;\n          onMouseLeave: MouseEventHandler<Target>;\n      }\n    : DetectType extends LongPressDetectEvents.TOUCH\n    ? {\n          onTouchStart: TouchEventHandler<Target>;\n          onTouchEnd: TouchEventHandler<Target>;\n      }\n    : never;\n\nexport interface LongPressOptions<Target = Element> {\n    threshold?: number;\n    captureEvent?: boolean;\n    detect?: LongPressDetectEvents;\n    onStart?: LongPressCallback<Target>;\n    onFinish?: LongPressCallback<Target>;\n    onCancel?: LongPressCallback<Target>;\n}\n\nexport function useLongPress<Target = Element>(callback: null, options?: LongPressOptions<Target>): {};\nexport function useLongPress<\n    Target = Element,\n    Callback extends LongPressCallback<Target> = LongPressCallback<Target>\n>(callback: Callback, options?: LongPressOptions<Target>): LongPressResult<Target, Callback>;\nexport function useLongPress<\n    Target = Element,\n    Callback extends LongPressCallback<Target> = LongPressCallback<Target>\n>(callback: Callback | null, options?: LongPressOptions<Target>): LongPressResult<Target, Callback> | {};\n/**\n * Detect click / tap and hold event\n *\n * @param callback <p>\n *   Function to call when long press event is detected\n *   (click or tap lasts for <i>threshold</i> amount of time or longer)\n *   </p>\n * @param options <ul>\n * <li><b>threshold</b>\n * - Period of time that must elapse after detecting click or tap in order to trigger <i>callback</i></li>\n * <li><b>captureEvent</b>\n * - If React Event will be supplied as first argument to all callbacks</li>\n * <li><b>detect</b>\n * - Which type of events should be detected ('mouse' | 'touch' | 'both' )\n * <li><b>onStart</b>\n * - Called right after detecting click / tap event (e.g. onMouseDown or onTouchStart)\n * <li><b>onFinish</b>\n * - Called (if long press <u>was triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * <li><b>onCancel</b>\n * - Called (if long press <u>was <b>not</b> triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * </ul>\n */\nexport function useLongPress<\n    Target = Element,\n    Callback extends LongPressCallback<Target> = LongPressCallback<Target>\n>(\n    callback: Callback | null,\n    {\n        threshold = 400,\n        captureEvent = false,\n        detect = LongPressDetectEvents.BOTH,\n        onStart = noop,\n        onFinish = noop,\n        onCancel = noop,\n    }: LongPressOptions<Target> = {}\n): LongPressResult<Target, Callback, typeof detect> | {} {\n    const isLongPressActive = useRef(false);\n    const isPressed = useRef(false);\n    const timer = useRef<NodeJS.Timeout>();\n    const savedCallback = useRef(callback);\n\n    const start = useCallback(\n        (event: LongPressEvent<Target>) => {\n            // Prevent multiple start triggers\n            if (isPressed.current) {\n                return;\n            }\n            if (captureEvent) {\n                event.persist();\n            }\n            // When touched trigger onStart and start timer\n            captureEvent ? onStart(event) : onStart();\n            isPressed.current = true;\n            timer.current = setTimeout(() => {\n                if (savedCallback.current) {\n                    captureEvent ? savedCallback.current(event) : savedCallback.current();\n                    isLongPressActive.current = true;\n                }\n            }, threshold);\n        },\n        [onStart, captureEvent, threshold]\n    );\n\n    const cancel = useCallback(\n        (event: LongPressEvent<Target>) => {\n            if (captureEvent) {\n                event.persist();\n            }\n            // Trigger onFinish callback only if timer was active\n            if (isLongPressActive.current) {\n                captureEvent ? onFinish(event) : onFinish();\n            } else if (isPressed.current) {\n                // Otherwise if not active trigger onCancel\n                captureEvent ? onCancel(event) : onCancel();\n            }\n            isLongPressActive.current = false;\n            isPressed.current = false;\n            timer.current !== undefined && clearTimeout(timer.current);\n        },\n        [captureEvent, onFinish, onCancel]\n    );\n\n    useEffect(\n        () => (): void => {\n            // Clear timeout on unmount\n            timer.current !== undefined && clearTimeout(timer.current);\n        },\n        []\n    );\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    const mouseHandlers = {\n        onMouseDown: start as MouseEventHandler<Target>,\n        onMouseUp: cancel as MouseEventHandler<Target>,\n        onMouseLeave: cancel as MouseEventHandler<Target>,\n    };\n\n    const touchHandlers = {\n        onTouchStart: start as TouchEventHandler<Target>,\n        onTouchEnd: cancel as TouchEventHandler<Target>,\n    };\n\n    // eslint-disable-next-line no-nested-ternary\n    return callback === null\n        ? {}\n        : // eslint-disable-next-line no-nested-ternary\n        detect === LongPressDetectEvents.MOUSE\n        ? mouseHandlers\n        : detect === LongPressDetectEvents.TOUCH\n        ? touchHandlers\n        : { ...mouseHandlers, ...touchHandlers };\n}\n"],"names":["LongPressDetectEvents","noop","callback","BOTH","isLongPressActive","useRef","isPressed","timer","savedCallback","start","useCallback","event","current","captureEvent","persist","onStart","setTimeout","threshold","cancel","onFinish","onCancel","undefined","clearTimeout","useEffect","mouseHandlers","onMouseDown","onMouseUp","onMouseLeave","touchHandlers","onTouchStart","onTouchEnd","detect","MOUSE","TOUCH","Object"],"mappings":"IAcYA,qBAJNC,gBAIMD,EAAAA,gCAAAA,+CAERA,gBACAA,8CA0EAE,oBAQ8B,qCANd,0CACG,iCACNF,8BAAsBG,qCACrBF,mCACCA,mCACAA,OAGTG,EAAoBC,UAAO,GAC3BC,EAAYD,UAAO,GACnBE,EAAQF,WACRG,EAAgBH,SAAOH,GAEvBO,EAAQC,uBACTC,GAEOL,EAAUM,UAGVC,GACAF,EAAMG,UAGVD,EAAeE,EAAQJ,GAASI,IAChCT,EAAUM,SAAU,EACpBL,EAAMK,QAAUI,sBACRR,EAAcI,UACdC,EAAeL,EAAcI,QAAQD,GAASH,EAAcI,UAC5DR,EAAkBQ,SAAU,IAEjCK,KAEP,CAACF,EAASF,EAAcI,IAGtBC,EAASR,uBACVC,GACOE,GACAF,EAAMG,UAGNV,EAAkBQ,QAClBC,EAAeM,EAASR,GAASQ,IAC1Bb,EAAUM,UAEjBC,EAAeO,EAAST,GAASS,KAErChB,EAAkBQ,SAAU,EAC5BN,EAAUM,SAAU,OACFS,IAAlBd,EAAMK,SAAyBU,aAAaf,EAAMK,UAEtD,CAACC,EAAcM,EAAUC,IAG7BG,8CAG0BF,IAAlBd,EAAMK,SAAyBU,aAAaf,EAAMK,WAEtD,IAGJW,uBACIf,EAAcI,QAAUV,GACzB,CAACA,QAEEsB,EAAgB,CAClBC,YAAahB,EACbiB,UAAWR,EACXS,aAAcT,GAGZU,EAAgB,CAClBC,aAAcpB,EACdqB,WAAYZ,UAII,OAAbhB,EACD,GAEF6B,IAAW/B,8BAAsBgC,MAC/BR,EACAO,IAAW/B,8BAAsBiC,MACjCL,EACAM,iBAAKV,EAAkBI"}